### --- *nix --- ###
cd()
{
	builtin cd $@
	ls
}

### --- Golang --- ###

# vg: is a vim opener for gofiles, the idea is that with go the application code and test code are in the same package
#     therefore, we can open both the application code and test code with one command.
vg()
{
	filename="$(echo $1 | sed 's/.go//g')"

	file="${filename}.go"
	testfile="${filename}_test.go"

	nvim -O $file $testfile
}

# gtouch: creates the correct file structure with the correct package name for application and test code given
#         a file name.
gtouch()
{
	filename="$(echo $1 | sed 's/.go//g')"

	file="${filename}.go"
	testfile="${filename}_test.go"

	package=$(echo ${PWD##*/} | sed 's/-//g')

	echo "package $package" >> $file  &&\
	echo "package $package" >> $testfile

	vg $filename
}


### --- Git --- ###
gb()
{
    if ! command -v fzf &> /dev/null
    then
        git branch
    else
        git branch | fzf
    fi
}

gbc()
{
    if ! command -v fzf &> /dev/null
    then
        git branch
    else
       git checkout $(git branch | fzf)
    fi
}

gr()
{
    local git_root
    git_root=$(git rev-parse --show-toplevel 2> /dev/null)

    if [[ -n "$git_root" ]]; then
        # If git_root is not empty, cd into the git root directory
        cd "$git_root" || return
    else
        # noop
    fi
}


### --- Diary --- ###
diary()
{
    DAY="$(date +'%a' | awk '{print tolower($0)}')"
    YEAR="$(date +'%Y')"
    MONTH="$(date +'%m')"
    TODAY="$(date +'%Y_%m_%d')"

    if [ ! -d $HOME/wiki/diary/$YEAR/$MONTH ];
    then
        mkdir -p $HOME/wiki/diary/$YEAR/$MONTH
    fi

    FILENAME=$HOME/wiki/diary/$YEAR/$MONTH/${DAY}_${TODAY}.md

    if [ ! -f $FILENAME ]
    then
        touch $FILENAME

        echo "# Diary: $(echo $DAY $TODAY | sed 's/_/ /g')\n" >> $FILENAME
        cat $HOME/wiki/templates/$(echo $WIKI_DIARY_TEMPLATE) | envsubst >> $FILENAME
    fi

    $EDITOR $FILENAME
}

### --- Journal --- ###
journal()
{
    DAY="$(date +'%a' | awk '{print tolower($0)}')"
    YEAR="$(date +'%Y')"
    MONTH="$(date +'%m')"
    TODAY="$(date +'%Y_%m_%d')"

    if [ ! -d $HOME/wiki/journal/$YEAR/$MONTH ];
    then
        mkdir -p $HOME/wiki/journal/$YEAR/$MONTH
    fi

    FILENAME=$HOME/wiki/journal/$YEAR/$MONTH/${DAY}_${TODAY}.md

    if [ ! -f $FILENAME ]
    then
        touch $FILENAME

        echo "# Journal: $(echo $DAY $TODAY | sed 's/_/ /g')\n" >> $FILENAME
        cat $HOME/wiki/templates/$(echo $WIKI_JOURNAL_TEMPLATE) | envsubst >> $FILENAME
    fi

    $EDITOR $FILENAME
}

### --- Trips --- ###
trip()
{
    if [ ! -d $HOME/wiki/trips ];
    then
        mkdir $HOME/wiki/trips
    fi

    FORMAT="$(echo $WIKI_CURRENT_TRIP | sed 's/ //g' | sed 's/,/_/g' |  awk '{print tolower($0)}')"
    FILENAME=$HOME/wiki/trips/$FORMAT.md

    if [ ! -f $FILENAME ]
    then
        touch $FILENAME

        echo "# Trip: $WIKI_CURRENT_TRIP $WIKI_CURRENT_TRIP_EMOJI \n" >> $FILENAME
        cat $HOME/wiki/templates/$(echo $WIKI_TRIP_TEMPLATE) | envsubst >> $FILENAME
    fi


    $EDITOR $FILENAME
}

### --- Location --- ###
loc()
{
    if [ ! -d $HOME/wiki/location];
    then
        mkdir $HOME/wiki/location
    fi

    YEAR="$(date +'%Y')"
    FILENAME=$HOME/wiki/location/$YEAR.md

    if [ ! -f $FILENAME ]
    then
        touch $FILENAME

        echo "# Location: $(echo $YEAR)\n" >> $FILENAME
        cat $HOME/wiki/templates/$(echo $WIKI_LOCATION_TEMPLATE) | envsubst >> $FILENAME
    fi

    $EDITOR $FILENAME
}

### --- Language --- ###
lang()
{
    DAY="$(date +'%a' | awk '{print tolower($0)}')"
    YEAR="$(date +'%Y')"
    MONTH="$(date +'%m')"
    TODAY="$(date +'%Y_%m_%d')"

    if [ ! -d $HOME/wiki/lang/$WIKI_LANG/$YEAR/$MONTH ];
    then
        mkdir -p $HOME/wiki/lang/$WIKI_LANG/$YEAR/$MONTH
    fi

    FILENAME=$HOME/wiki/lang/$WIKI_LANG/$YEAR/$MONTH/${DAY}_${TODAY}.md

    if [ ! -f $FILENAME ]
    then
        touch $FILENAME

        echo "# Lang Journal: $(echo $DAY $TODAY | sed 's/_/ /g')\n" >> $FILENAME
    fi

    $EDITOR $FILENAME
}

### --- Ping --- ###
pg()
{
    ping www.google.com
}

### --- Buylist --- ###
buylist()
{
    F=$HOME/wiki/finances/buylist.md

    if [ ! -f $F ]
    then
        touch $F
        echo "# Buylist ðŸ¤‘" > $F
    fi

    $EDITOR $F
}

### --- This week I learnt --- ###
twil()
{
    local year=$(date +%Y)

    local directory_path=$WIKI/learning/twil/$year
    mkdir -p $directory_path

    local week_number=$(date +%V)

    local file_path=$directory_path/$week_number.md

    if [ ! -f $file_path ]; then
        touch $file_path

        echo "# ðŸ§  TWIL WEEKLY: $week_number" >> $file_path
        echo "" >> $file_path
    fi

    $EDITOR $file_path
}

### --- Retro --- ###
retro()
{
        local template=$WIKI/templates/$WIKI_RETRO_TEMPLATE

        local date_format="%d_%m_%Y"
        local current_date=$(date +$date_format)

        local year=$(date +%Y)
        local week_number=$(date +%U)

        local directory_path=$WIKI/retro/$year
        mkdir -p $directory_path
        local file_path=$directory_path/$week_number.md

        if [ ! -f $file_path ]; then
            touch $file_path

            echo "# RETRO: $current_date" >> $file_path
            echo "" >> $file_path
            cat $template | envsubst >> $file_path
        fi

        $EDITOR $file_path
}

### --- TODO --- ###
todo()
{
    if [ $# -eq 0 ]; then
        todo -w
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d)
                local template=$WIKI/templates/$WIKI_TODO_DAILY_TEMPLATE

                local date_format="%d_%m_%Y"
                local current_date=$(date +$date_format)

                local year=$(date +%Y)
                local month=$(date +%m)

                local directory_path=$WIKI/todo/daily/$year/$month
                mkdir -p $directory_path

                local file_path=$directory_path/$current_date.md
                if [ ! -f $file_path ]; then
                    touch $file_path

                    echo "# TODO DAILY: $current_date" >> $file_path
                    echo "" >> $file_path
                    cat $template | envsubst >> $file_path
                fi

                $EDITOR $file_path
                ;;
            -e)
                local template=$WIKI/templates/$WIKI_TODO_ENG_WEEKLY_TEMPLATE

                local year=$(date +%Y)

                local directory_path=$WIKI/todo/eng/weekly/$year
                mkdir -p $directory_path

                local week_number=$(date +%U)

                local file_path=$directory_path/$week_number.md

                if [ ! -f $file_path ]; then
                    touch $file_path

                    echo "# ðŸ¤– TODO ENG WEEKLY: $week_number" >> $file_path
                    echo "" >> $file_path
                    cat $template | envsubst >> $file_path
                fi

                $EDITOR $file_path
                ;;
            *)
                local template=$WIKI/templates/$WIKI_TODO_WEEKLY_TEMPLATE

                local year=$(date +%Y)

                local directory_path=$WIKI/todo/weekly/$year
                mkdir -p $directory_path

                local week_number=$(date +%U)

                local file_path=$directory_path/$week_number.md

                if [ ! -f $file_path ]; then
                    touch $file_path

                    echo "# ðŸ“’ TODO WEEKLY: $week_number" >> $file_path
                    echo "" >> $file_path
                    cat $template | envsubst >> $file_path
                fi

                $EDITOR $file_path
                ;;
        esac
        shift
    done
}

thoughts()
{
    $EDITOR $HOME/wiki/thoughts
}

goals()
{
    local year=$(date +%Y)
    $EDITOR $HOME/wiki/planning/$year/goals.md
}

reading()
{
    $EDITOR $HOME/wiki/books/to_read.md
}

# Reinstates the current branch by pulling the latest changes from the origin.
gbpn()
{
  ## TODO: add emojis

  current_branch=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
  echo "current_branch=$current_branch"

  default_branch=$(git symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/heads/@@' | sed 's/origin/\///g')
  echo "default_branch=$default_branch"

  echo "refreshing current from from default branch"

  git checkout $default_branch && echo "checkout out to $default_branch" && \
    git branch -D $current_branch && echo "deleted branch $current_branch" && \
    git pull && git fetch && echo "pulled & fetched latest from origin" && \
    git checkout $current_branch && echo "checked out to $current_branch"

  echo ""
  echo "Done"
}

### Project Planning
proj()
{
  command -v minijira >/dev/null 2>&1 || { echo "ðŸš¨ minijira not found"; exit 1; }

  if [ $# -eq 0 ]; then
    minijira
  else
    minijira "$1"
  fi
}

pb()
{
  proj bpx-backend
}

prl()
{
  proj replog
}

pi()
{
    proj intervention

}

### shortcuts
blog()
{
    $EDITOR $WIKI_BLOG
}

## History
fzf_history_widget()
{
  local selected

  selected=$(fzf-history-finder "$LBUFFER") || return

  [[ -z "$selected" ]] && zle redisplay && return

  BUFFER="$selected"
  CURSOR=${#BUFFER}
  zle redisplay
}

### AWS
faws() {
if ! command -v aws >/dev/null 2>&1; then
  echo "aws CLI not found" >&2
  exit 1
fi

if ! command -v fzf >/dev/null 2>&1; then
  echo "ðŸš¨ fzf not found" >&2
  exit 1
fi

profile=$(aws configure list-profiles | fzf --height 40% --reverse --border) || exit 0
export AWS_PROFILE="$profile"
echo "âœ…ðŸ¤– Set AWS_PROFILE to: ${profile}"
}

### --- Git Worktree Units --- ###

# unit-new: Create a new worktree and cd into it
# Usage: unit-new <ticket-name> [branch-name]
unit-new() {
    local DOTF_AGENTS_WORKTREE_DIR="${DOTF_AGENTS_WORKTREE_DIR:-.agents}"

    if [[ -z "$1" ]]; then
        echo "Usage: unit-new <ticket-name> [branch-name]" >&2
        return 1
    fi

    local TICKET="$1"
    local BRANCH="${2:-$TICKET}"

    local REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -z "$REPO_ROOT" ]]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi

    local REPO_NAME=$(basename "$REPO_ROOT" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]-' '-' | sed 's/^-//;s/-$//')
    local WORKTREE_PATH="$REPO_ROOT/$DOTF_AGENTS_WORKTREE_DIR/$TICKET"

    if [[ -d "$WORKTREE_PATH" ]]; then
        echo "Error: Worktree already exists at $WORKTREE_PATH" >&2
        echo "Use 'unit-cd' to switch to it" >&2
        return 1
    fi

    mkdir -p "$REPO_ROOT/$DOTF_AGENTS_WORKTREE_DIR"

    echo "Fetching latest from origin..."
    git fetch origin

    local BASE_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [[ -z "$BASE_BRANCH" ]]; then
        if git show-ref --verify --quiet refs/remotes/origin/main; then
            BASE_BRANCH="main"
        else
            BASE_BRANCH="master"
        fi
    fi

    echo "Creating worktree at $WORKTREE_PATH..."
    git worktree add -b "$BRANCH" "$WORKTREE_PATH" "origin/$BASE_BRANCH"

    # Rename tmux pane if in tmux
    if [[ -n "$TMUX" ]]; then
        local CURRENT_TITLE=$(tmux display-message -p '#{pane_title}')
        local TICKET_NORMALIZED=$(echo "$TICKET" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]-' '-' | sed 's/^-//;s/-$//')

        local NEW_TITLE
        if [[ "$CURRENT_TITLE" =~ ^(.+:agent-[0-9]+) ]]; then
            NEW_TITLE="${match[1]}:${TICKET_NORMALIZED}"
        else
            NEW_TITLE="${REPO_NAME}:${TICKET_NORMALIZED}"
        fi
        tmux select-pane -T "$NEW_TITLE"
    fi

    echo ""
    echo "Created worktree for $TICKET"
    echo "  Branch: $BRANCH (from $BASE_BRANCH)"
    echo ""

    # Auto-cd into worktree
    cd "$WORKTREE_PATH"
    echo "Now in: $(pwd)"
}

# unit-cd: fzf picker to cd into a worktree
# Usage: unit-cd
unit-cd() {
    local DOTF_AGENTS_WORKTREE_DIR="${DOTF_AGENTS_WORKTREE_DIR:-.agents}"

    local REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -z "$REPO_ROOT" ]]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi

    local WORKTREE_BASE="$REPO_ROOT/$DOTF_AGENTS_WORKTREE_DIR"

    if [[ ! -d "$WORKTREE_BASE" ]]; then
        echo "No worktrees found. Use 'unit-new <ticket>' to create one." >&2
        return 1
    fi

    local tickets=($(ls -1 "$WORKTREE_BASE" 2>/dev/null))
    if [[ ${#tickets[@]} -eq 0 ]]; then
        echo "No worktrees found. Use 'unit-new <ticket>' to create one." >&2
        return 1
    fi

    local selected=$(printf '%s\n' "${tickets[@]}" | fzf --height 40% --reverse --border --header "Select worktree")

    if [[ -z "$selected" ]]; then
        return 0
    fi

    local WORKTREE_PATH="$WORKTREE_BASE/$selected"

    # Rename tmux pane if in tmux
    if [[ -n "$TMUX" ]]; then
        local REPO_NAME=$(basename "$REPO_ROOT" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]-' '-' | sed 's/^-//;s/-$//')
        local CURRENT_TITLE=$(tmux display-message -p '#{pane_title}')
        local TICKET_NORMALIZED=$(echo "$selected" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]-' '-' | sed 's/^-//;s/-$//')

        local NEW_TITLE
        if [[ "$CURRENT_TITLE" =~ ^(.+:agent-[0-9]+) ]]; then
            NEW_TITLE="${match[1]}:${TICKET_NORMALIZED}"
        else
            NEW_TITLE="${REPO_NAME}:${TICKET_NORMALIZED}"
        fi
        tmux select-pane -T "$NEW_TITLE"
    fi

    cd "$WORKTREE_PATH"
    echo "Now in: $(pwd)"
}

# unit-rm: fzf picker to remove a worktree (or current if in one)
# Usage: unit-rm [-y]
unit-rm() {
    local DOTF_AGENTS_WORKTREE_DIR="${DOTF_AGENTS_WORKTREE_DIR:-.agents}"
    local AUTO_DELETE=""

    if [[ "$1" == "-y" ]]; then
        AUTO_DELETE="yes"
    fi

    local CURRENT_PATH=$(pwd)
    local WORKTREE_PATH=""
    local TICKET=""
    local MAIN_REPO=""

    # Get main repo root (works from worktree or main repo)
    local GIT_COMMON_DIR=$(git rev-parse --git-common-dir 2>/dev/null)
    if [[ -z "$GIT_COMMON_DIR" ]]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi

    # Resolve to absolute path and get parent (the main repo)
    if [[ "$GIT_COMMON_DIR" == ".git" ]]; then
        MAIN_REPO=$(git rev-parse --show-toplevel)
    else
        MAIN_REPO=$(dirname "$GIT_COMMON_DIR")
    fi

    local REPO_NAME=$(basename "$MAIN_REPO" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]-' '-' | sed 's/^-//;s/-$//')
    local WORKTREE_BASE="$MAIN_REPO/$DOTF_AGENTS_WORKTREE_DIR"

    # Check if we're inside a worktree (current path contains .agents)
    if [[ "$CURRENT_PATH" == *"/$DOTF_AGENTS_WORKTREE_DIR/"* ]]; then
        # Extract worktree path
        WORKTREE_PATH="${CURRENT_PATH%%/$DOTF_AGENTS_WORKTREE_DIR/*}/$DOTF_AGENTS_WORKTREE_DIR"
        WORKTREE_PATH="$WORKTREE_PATH/${CURRENT_PATH#*/$DOTF_AGENTS_WORKTREE_DIR/}"
        WORKTREE_PATH="${WORKTREE_PATH%%/*}"
        # Rebuild proper path
        local TEMP="${CURRENT_PATH#*/$DOTF_AGENTS_WORKTREE_DIR/}"
        TICKET="${TEMP%%/*}"
        WORKTREE_PATH="$WORKTREE_BASE/$TICKET"
        echo "Currently in worktree: $TICKET"
    else
        # fzf picker
        if [[ ! -d "$WORKTREE_BASE" ]]; then
            echo "No worktrees found." >&2
            return 1
        fi

        local tickets=($(ls -1 "$WORKTREE_BASE" 2>/dev/null))
        if [[ ${#tickets[@]} -eq 0 ]]; then
            echo "No worktrees found." >&2
            return 1
        fi

        TICKET=$(printf '%s\n' "${tickets[@]}" | fzf --height 40% --reverse --border --header "Select worktree to remove")

        if [[ -z "$TICKET" ]]; then
            return 0
        fi

        WORKTREE_PATH="$WORKTREE_BASE/$TICKET"
    fi

    # Check for uncommitted changes
    local HAS_CHANGES=$(git -C "$WORKTREE_PATH" status --porcelain 2>/dev/null)
    if [[ -n "$HAS_CHANGES" ]]; then
        echo "Warning: Worktree has uncommitted changes!"
        git -C "$WORKTREE_PATH" status --short
        echo ""
        echo -n "Continue anyway? [y/N] "
        read -r REPLY
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted"
            return 1
        fi
    fi

    # Check for unpushed commits
    local BRANCH=$(git -C "$WORKTREE_PATH" rev-parse --abbrev-ref HEAD 2>/dev/null || true)
    if [[ -n "$BRANCH" ]] && [[ "$BRANCH" != "HEAD" ]]; then
        local UNPUSHED=$(git -C "$WORKTREE_PATH" log --oneline "@{upstream}..HEAD" 2>/dev/null)
        if [[ -n "$UNPUSHED" ]]; then
            echo "Warning: Worktree has unpushed commits!"
            echo "$UNPUSHED"
            echo ""
            echo -n "Continue anyway? [y/N] "
            read -r REPLY
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Aborted"
                return 1
            fi
        fi
    fi

    echo "Removing worktree: $TICKET"
    echo "  Path: $WORKTREE_PATH"
    echo "  Branch: $BRANCH"

    # Move out if we're in the worktree
    if [[ "$CURRENT_PATH" == "$WORKTREE_PATH"* ]]; then
        cd "$MAIN_REPO"
        echo "Moved to: $MAIN_REPO"
    fi

    git worktree remove "$WORKTREE_PATH" --force

    # Handle branch deletion
    if [[ -n "$BRANCH" ]] && [[ "$BRANCH" != "HEAD" ]]; then
        if [[ "$AUTO_DELETE" == "yes" ]]; then
            git -C "$MAIN_REPO" branch -d "$BRANCH" 2>/dev/null || git -C "$MAIN_REPO" branch -D "$BRANCH"
            echo "Branch deleted"
        else
            echo -n "Delete branch '$BRANCH'? [y/N] "
            read -r REPLY
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                git -C "$MAIN_REPO" branch -d "$BRANCH" 2>/dev/null || git -C "$MAIN_REPO" branch -D "$BRANCH"
                echo "Branch deleted"
            fi
        fi
    fi

    # Reset tmux pane name
    if [[ -n "$TMUX" ]]; then
        local CURRENT_TITLE=$(tmux display-message -p '#{pane_title}')
        if [[ "$CURRENT_TITLE" =~ ^(.+:agent-[0-9]+):.+ ]]; then
            tmux select-pane -T "${match[1]}"
        fi
    fi

    echo "Worktree $TICKET removed"
}
